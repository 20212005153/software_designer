下午题最难的部分

## 数组与矩阵

### 数组存储地址的计算

![1697457562498](06软考数据结构.assets\1697457562498.png)

**注意存储的方式**

### 稀疏矩阵

产生原因：数组存储了大量相同的元素

**计算稀疏数组某元素的下标**
![1697457743023](06软考数据结构.assets\1697457743023.png)

考试中可以直接使用选项代入验证。

---

## 线性表（重要

数据结构包括线性结构和非线性结构。
线性表常见的两种存储结构：

- 顺序存储结构 **顺序表**
- 链式存储结构 **链表**

![1697458207937](06软考数据结构.assets\1697458207937.png)

链表的基本操作

![1697458284758](06软考数据结构.assets\1697458284758.png)

要知道具体是如何实现的

### 线性表-顺序存储与链式存储对比

![1697458733398](06软考数据结构.assets\1697458733398.png)

由于存在指针域和数据域以及非连续分布  链式存储的空间密度要小于1。

### 队列与栈（每次都考

![1697459229587](06软考数据结构.assets\1697459229587.png)

**利用两个栈可以模拟一个队列，反之不可。**

为避免队空条件与队满条件冲突，循环队列通过浪费一个存储空间来判断队满。

![1697459654049](06软考数据结构.assets\1697459654049.png)

## 广义表

![1697459961915](06软考数据结构.assets\1697459961915.png)

深度：递归的层数
表尾：除第一个元素外的所有元素组成**的广义表**

例2取b元素：head(head(tail(LS1)))

## 树与二叉树（重要

树节点的度：节点的孩子节点数
**树的度：最大树节点的度**
层次

内部节点：既不是叶子节点 又不是根节点

### 完全二叉树

直观特点：减去最底层是一颗满二叉树；叶子节点从左到右排列

![1697460726604](06软考数据结构.assets\1697460726604.png)
第三点是一个特性 死记硬背即可 **n0=n2+1是二叉树的重要特性**   

### 二叉树遍历

- 前序遍历
- 中序遍历
- 后序遍历
- 层次遍历

![1697461058505](06软考数据结构.assets\1697461058505.png)

层：12345678 前：12457836 中：42785126 后：48752631

### 反向构造二叉树

知道遍历顺序来构造二叉树
知道前序和中序或中序和后序都可以构造二叉树

由前序序列为ABHFDECG; 中序序列为HBEDFAGC构造二又树

![1697461553790](06软考数据结构.assets\1697461553790.png)

### 树转化为二叉树

原则：**第一个孩子节点变为左节点 第一个兄弟节点变为右节点**
连线法：
![1697461817114](06软考数据结构.assets\1697461817114-1697461877735-13.png)

### 查找二叉树

特点：**左孩子小于根  右孩子大于根**
![1697462124373](06软考数据结构.assets\1697462124373.png)

基本操作：
![1697462397206](06软考数据结构.assets\1697462397206.png)

删除有两个子节点的节点有点难

### 最优二叉树（哈夫曼树

应用于无损压缩技术

路径长度：经历过的边数
带权路径长度：路径长度乘以节点权值
树的带权路径长度：**叶子节点**的带权路径长度之和

构造哈夫曼树就是构造**最小带权路径长度的树**
![1697462910597](06软考数据结构.assets\1697462910597.png)

不断地选取两个最小的数**出来** 将两个之和的结果重新放入数组 不断重复直至数组剩下元素（根节点）；
当本次拿到的两个元素**和之前构造的树无任何联系**时，重新构造新的树。   
**注意！小的节点要排在左边，哪怕是移动整颗子树。**
路径左0右1.        

求压缩比=定长编码ACL/哈夫曼编码ACL

### 线索二叉树

产生原因：**指向空指针**是一种浪费空间资源的行为
线索（原本的空指针）指向对应遍历顺序中的相邻节点 若无 则使用NULL表示

![1697463768199](06软考数据结构.assets\1697463768199.png)
前序遍历：ABDEHCFGI 所以D的左节点指向B 右节点指向E

### 平衡二叉树

**也是排序二叉树**
产生原因：拥有相同节点的排序二叉树可以具有不一样的结构
![1697463946089](06软考数据结构.assets\1697463946089.png)

平衡度：左子树深度-右子树深度

平衡二叉树特性：

- 任意结点的左右子树深度相差不超过1
- 每结点的平衡度只能为-1、0或1

调整：

1。**找到最小不平衡子树**（和其根节点）

2。**从根节点出发，沿插入路径找三个节点**。

3。**调整这三个节点。**（找出中位数，让中位数作为根节点，其余两个一左一右）

4。**剩下的节点，左右子树的位置保持不变，再找到最后一个节点的插入位置。**

## 图（考察频度比树小很多

### 完全图

- 在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图
- 在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图

![1697529560741](06软考数据结构.assets\1697529560741.png)

无向完全图的边数为n*（n-1）/ 2。

### 图的存储

**邻接矩阵**
DFS时间复杂度为O（n的平方）

![1697529649215](06软考数据结构.assets\1697529649215.png)

邻接矩阵**对于[0,0]的点**，即对于自身**赋零**。
顶点数决定邻接矩阵的阶和邻接表的单链表数目，边数影响节点数目（无论有无向）。完全图适合采用邻接矩阵存储。

对于无向图，可以存为上三角或下三角

**邻接表**

会用一个一维数组记录各点可以到的顶点情况。

DFS时间复杂度为O（n+e)
![1697529988620](06软考数据结构.assets\1697529988620.png)

---

### 图的遍历

DFS，BFS        

**遍历是指访问图中所有顶点且只访问一次，BFS借助队列。**    

![   ](06软考数据结构.assets\1697530102565.png)

在邻接表遍历图
![1697530215100](06软考数据结构.assets\1697530215100.png)
BFS：0 4 3 1 6 2 7 5
DFS：0 4 6 7 3 1 2 5 

---

### 拓扑排序

![1697530577007](06软考数据结构.assets\1697530577007.png)
AOV：表示活动的优先级 无权值
AOE：带权值 表示持续时间

拓扑序列：02143657等等

### 图的最小生成树

树和图最大的区别就是树没有环路

最小生成树 ：以最小代价遍历图中各顶点

### 普利姆PRIM算法

选择任意节点作为初始点，不断地选择能以最小代价到达的点加入该集合。（贪心）
![1697550114467](06软考数据结构.assets\1697550114467.png)

### 克鲁斯卡尔算法

在不形成环路的前提下，不断地选取最小代价的边。（贪心）
![1697550271409](06软考数据结构.assets\1697550271409.png)

---

## 排序与查找（重要

算法的特性：
![1697550497793](06软考数据结构.assets\1697550497793.png)

算法复杂度：

- 时间复杂度

  取函数内最高的时间复杂度即可
  如果**每个递归步骤的时间复杂度为 0(f(n)）**，且递归的**深度为 k**，那么递归函数的**时间复杂度为 O(k* f(n))**

- 空间复杂度 

  空间复杂度只考虑在运行过程中**为局部变量分配的存储空间的大小**

---

### 顺序查找

思想: 将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功;否则，则查找失败。

平均查找长度ASL=(n+1)/2
时间复杂度：O(n)

### 二分查找

前提：有序序列

时间复杂度：O(log2 n)

成功查找次数：各层数*各层的节点数/非空节点数
失败 查找次数：到达空节点的路径长度*各路径的节点数/空节点个数

---

### 散列表

基本思想是:设计一个函数Hash，将关键字映射到一个有限的、地址连续的区间T中，区间就称为散列表，散列查找中使用的**转换函数**称为**散列函数**。

处理冲突：线性探测法 伪随机数法

![1697551912927](06软考数据结构.assets\1697551912927.png)

---

### 排序

**稳定**：在排序前，（可以相等）元素A在元素B之前，再排序后A依旧在B前，就是稳定；反之则为不稳定。

内排序与外排序：内排序是在内存里的排序，外排序是在外部空间的排序。

**分类（前三个考察概率高，后两个较难考察概率低**：
插入类排序

- 直接插入排序 
- 希尔排序

交换类排序

- 冒泡排序 
- 快速排序

选择类排序

- 简单选择排序 
- 堆排序

归并排序

基数排序

---

### 直接插入排序

![1697552564031](06软考数据结构.assets\1697552564031.png)

### 希尔排序

关键字：增量 分组 增量倍缩 直接插入排序

![1697552942493](06软考数据结构.assets\1697552942493.png)

### 直接选择排序

![1697553087925](06软考数据结构.assets\1697553087925.png)

### 堆排序

![1697590404710](06软考数据结构.assets\1697590404710.png)

![1697590845890](06软考数据结构.assets\1697590845890.png)

时间复杂度：nlog2 n

### 冒泡排序

![1697590957974](06软考数据结构.assets\1697590957974.png)

### 快速排序

关键字：基准 每次都是确定哨兵的位置 分治

最佳的基准元素选择的方式是选择中位数元素。   

![1697591140629](06软考数据结构.assets\1697591140629.png)

### 归并排序

关键字：合并两个有序数组 减治法 

![1697591352431](06软考数据结构.assets\1697591352431.png)

### 基数排序

要点：将单个关键字拆分为多个关键字 对每个关键字排序

![1697591724897](06软考数据结构.assets\1697591724897.png)

### 总结

![1697591832656](06软考数据结构.assets\1697591832656.png)

快速排序空间复杂度是O(log2 n)：其实使用了分治的思想 共log2 n层

## 算法基础及常见的算法（重要

后面的区域等以后再来吧~~~