## 瀑布模型SDLC

基本结构

![1697718181698](10软考开发模型.assets\1697718181698.png)

失败原因：需求阶段难以把控，等到测试完需求变化又得花费大量人力物力

结构化方法，用于结构化开发

应用场景：需求明确或二次开发或使用其他模型明确需求在使用瀑布模型

## 原型

通过简易系统获得获得客户反馈来调整需求，属于需求分析阶段。

快速原型不适合大型项目开发。螺旋和UP比较适合。

![1697718648240](10软考开发模型.assets\1697718648240.png)

**原型法不能指导代码优化。**

增量模型：先做最核心的一部分再慢慢完善。**不利于好的模块划分**。

![1697718929136](10软考开发模型.assets\1697718929136.png)

螺旋模型具有多种模型的特征。最与众不同的：风险分析。
包含维护周期，**维护和开发没有本质区别**。

### V模型

![1697719312595](10软考开发模型.assets\1697719312595.png)

需求分析的时候就要考虑验收测试和系统测试，以此类推。

强调要及早地进行测试，测试要贯穿于开发的始终。

**喷泉模型**是面向对象的模型。

RAD快速开发模型，由瀑布模型和构件化开发模型组合而来。

## 构件组装模型（CBSD）

提高软件开发的复用性，减少开发时间和成本，提高可靠性。

![1697719643668](10软考开发模型.assets\1697719643668.png)

## 统一过程（UP）

![1697719970011](10软考开发模型.assets\1697719970011.png)

**用例和风险**为驱动。

UP现在定义了**五个阶段，起始，精化，构建，移交和产生阶段**，每阶段**达到某个里程碑时结束**。其中初启阶段的里程碑是**生命周期目标**，精化阶段的里程碑是生命周期**架构**，构建阶段的里程碑是**初始运作功能**，移交阶段的里程碑是**产品发布**。             

通过多轮的循环和迭代产出最终产品。

##  敏捷开发方法

为开发人员减负，将更多时间用于项目上，减少对于其他工作诸如编写文档的投入。

![1697720345110](10软考开发模型.assets\1697720345110.png)

敏捷开发适合开发中小型项目

- 极限编程XP是激发开发人员创造性、使得管理负担最小的一组技术；
- 水晶法Crystal认为每一个不同的项目都需要一套不同的策略、约定和方法论；
- 并列争球法（Scrum）使用迭代的方法，其中把每30天一次的迭代成为一个冲刺，并按需求的优先级来实现产品。多个自组织和自治小组并行地递增实现产品，并通过简短的日常情况会议进行协调。             

12个最佳实践：计划游戏（**快速制定计划**、随着细节的不断变化而完善）、小型发布（系统的设计要能够尽可能**早地交付**）、隐喻（找到合适的比喻传达信息）、简单设计（只处理当前的需求，使设计保持简单）、**测试先行（先写测试代码，然后再编写程序）**、重构（重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求）、结队编程、集体代码所有制、持续集成（可以按日甚至按小时为客户提供可运行的版本）、每周工作40个小时、现场客户和编码标准。             

Scrum使用的工件：Product backlog（产品功能列表）、Sprint backlog（迭代冲刺列表） 和 Burn Down Chart（燃尽图）涉及Sprint也对

## 信息系统开发方法

![1697720800717](10软考开发模型.assets\1697720800717.png)

结构化方法无法解决大型、变化复杂的问题。

## 需求分类和需求获取

![1697722537402](10软考开发模型.assets\1697722537402.png)

系统需求：计算机化能指导开发的需求

基本需求：客户明确的需求
期望需求：为达到用户的预期所需的需求，客户可能没明确提出
兴奋需求：在达到预期目标的前提下，新增的需求，提高客户的满意度，但风险极大，不推荐

---

## 结构化设计

### 基本原则

![1697723132946](10软考开发模型.assets\1697723132946.png)

信息屏蔽：内部信息不向外界展现 只展现接口

- 结构化设计方法中，概要设计阶段进行软件体系结构的设计、数据设计和接口设计；详细设计阶段进行数据结构和算法的设计。
- 面向对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计/数据设计、结构设计；详细设计阶段进行构件设计。

结构化设计和面向对象设计是两种不同的设计方法，**结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序**；**面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等**。

结构化分析模型包括**数据流图、实体联系图、状态迁移图和数据字典**，因此这些模型是**需求分析阶段的输出**。而**确定软件体系结构是在软件设计阶段**进行的。       

结构化**设计**主要包括： ①**体系**结构设计：定义软件的主要结构元素及其关系。 ②**数据**设计：**基于实体联系图**确定软件涉及的**文件系统的结构及数据库的表结构**。 ③**接口**设计：**基于数据流图**，描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口。 ④**过程**设计：确定软件各个组成部分内的**算法及内部数据结构**，并选定某种过程的表达形式来描述各种算法。     

**结构化开发方法**由结构化分析、结构化设计和结构化程序设计构成，是一种**面向数据流**的开发方法。结构化方法总的指导思想是自顶向下、逐层分解，基本原则是功能的分解与抽象。它是软件工程中最早出现的开发方法，**特别适合于数据处理领域的问题，但是不适合解决大规模的、特别复杂的项目，而且难以适应需求的变化**。**瀑布模型**就是一种结构化开发方法。

---

**仓库风格**是一种软件体系结构，其中**包含一个数据仓库和若干个其他构件**。数据仓库位于该体系结构的中心，其他构件访问该数据仓库并对其中的数据进行增、删、改等操作。**数据库系统、超文本系统和黑板系统都属于仓库风格**。 该体系结构的优点包括： ①**对可更改性和可维护性的支持； ②可复用的知识源； ③支持容错性和健壮性**。 缺点包括： ①**测试困难**； ②不能保证有好的解决方案； ③难以建立好的控制策略； ④低效； ⑤昂贵的开发工作； ⑥缺少对并行机制的支持。  

**管道过滤器体系结构风格**

![1698476089641](10软考开发模型.assets\1698476089641.png)

该风格具有以下优点： ①软件构件具有良好的**隐蔽性和高内聚、低耦合**的特点； ②允许设计者将整个系统的输入输出行为看成是多个过滤器的行为的简单合成； ③**支持软件复用**； ④系统维护和增强系统**性能简单**； ⑤允许对一些如吞吐量、死锁等属性的分析； ⑥**支持并行执行**。                         

---

内聚：模块内部各个部件连接的紧密程度
耦合：模块之间的联系

![1697723232986](10软考开发模型.assets\1697723232986.png)

多扇入：被调用的多 说明功能完善 高内聚
少扇出：职能少 就低耦合

启发式原则，根据这些原则进行设计，可以设计出较高质量的软件系统。其中，**模块的扇入扇出适中，模块大小适中以及完善模块功能都可以改进设计质量**。而**将相似功能的模块合并可能会降低模块内聚和提高模块之间的耦合，因此并不能改进设计质量**。             

内聚类型

![1697723263754](10软考开发模型.assets\1697723263754.png)

耦合类型

![1697723291370](10软考开发模型.assets\1697723291370.png)

系统/模块结构

![1697723388371](10软考开发模型.assets\1697723388371.png)

一个模块的**作用范围**（或称影响范围）指受该**模块内一个判定影响的所有模块的集**合。一个模块的**控制范围**指模块**本身以及其所有下属模块**（直接或间接从属于它的模块）的集合。一个模块的作用范围应在其控制范围之内，且判定所在的模块应在其影响的模块在层次上尽量靠近。如果再设计过程中，发现模块**作用范围不在其控制范围之内**，可以用**“上移判点”或“下移受判断影响的模块，将它下移到判断所在模块的控制范围内”**的方法加以改进。（扩大控制范围或减小作用范围）

模块分为四种类型。①传入模块:取得数据或输入数据，经过某些处理，再将其传送给其他模块.②传出模块：输出数据，在输出之前可能进行某些处理，数据可能被输出到系统的外部，或者会输出到其他模块进行进一步处理。③变换模块：**从上级调用模块得到数据**，进行特定的处理，转换成其他形式，在**将加工结果返回给调用模块**。④协调模块一般**不**对数据进行**加工**，主要是通过调用、协调和管理其他模块来完成特定的功能。          

系统结构图包括模块、模块之间的调用关系、通信和**控制**等4个部分。   

**系统设计**为系统制定蓝图，软件设计模型**关注**新系统**总体结构、代码设计、处理过程、数据结构和界面模型**等。对**项目范围的关注在软件设计之前。**             

---

## 软件测试

![1698065854599](10软考开发模型.assets\1698065854599.png)

回归测试：在改完bug后还是要测试 避免产生新的bug

![image-20231023205754638](10软考开发模型.assets\image-20231023205754638.png)

区别在于有没有利用到计算机

桌前检查：写完代码自查有没有bug
代码走查：模拟一个变量走流程
代码审查：程序员之间互查代码

---

### 测试用例设计

黑盒：看不见内部结构及其工作原理 只知道输出和输入
白盒：看得见内部结构及其工作原理

![image-20231023211829426](10软考开发模型.assets\image-20231023211829426.png)

白盒测试**根据程序的内部结构和逻辑**来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。白盒测试常用的技术涉及不同覆盖标准，在测试时需根据**指定的覆盖标准**确定测试数据。   

**语句覆盖**是被测程序中每条语句至少执行一次。**判定覆盖**是使得被测程序中**每个判定表达式至少获得一次“真”植和“假”值**。条件覆盖是使得每一个判定语句中每个逻辑条件的各种可能的值至少满足一次。路径覆盖是指覆盖被测程序中所有可能的路径。在这些覆盖技术中**，从弱到强依次为语句覆盖、判定覆盖、条件覆盖和路径覆盖。**覆盖越强，越能发现错误。     

对于**无法获得源代码**的第三方组件，可**采用黑盒测试**对组件进行测试。

---

## 测试阶段

测试的目标在需求分析阶段就已定义。

先单元测试 再集成测试
系统测试和确认测试可以先后倒置

![1698068255447](10软考开发模型.assets\1698068255447.png)

单元测试关注的层面是模块，函数有没有写好，功能有没有bug。
集成测试关注的是模块间的衔接。
确认测试确定的是需求。
系统测试偏重是压力测试性能测试。

负载测试：不同负载下的测试，看看性能表现
强度测试：系统出现异常情况下，能否进行运行
压力测试：测试临极限情况下的系统

---

## 软件评审

软件评审的内容包括**设计质量评审**、**程序质量**评审和与**运行环境接口**的评审。评审的主要**目标是为了发现软件中的错误**。  

通常从以下几个方面进行评审：
 ①评价**软件的规格说明是否合乎用户的要求**，即总体设计思想和设计方针是否明确；需求规格说明是否得到了用户或单位上级机关的批准；需求规格说明与软件的概要设计规格说明是否一致等。 
②**评审可靠性**，即是否能避免输入异常（错误或超载等）、硬件失效及软件失效所产生的失效，一旦发生应能及时采取代替手段或恢复手段。
③**评审保密措施**实现情况，即是否对系统使用资格进行检查；是否对特定数据、特定功能的使用资格进行检查；在检查出有违反使用资格的情况后，能否向系统管理人员报告有关信息；是否提供对系统内重要数据加密的功能等。
④评审**操作特性**实施情况，即操作命令和操作信息的恰当性，输入数据与输入控制语句的恰当性；输出数据的恰当性；应答时间的恰当性等。
⑤评审**性能**实现情况，即是否达到所规定性能的目标值。 
⑥评审软件是否具有**可修改性，可扩充性、可互换性和可移植性**。 
⑦评审软件是否具有**可测试性**。
⑧评审软件是否具有**复用性**。                        

**模块结构评审**时，主要包括以下方面的评审：

1.**控制流结构**：规定了处理模块与处理模块之间的流程关系。检查处理模块之间的控制转移关系与控制转移形式（调用方式）。
2.**数据流结构**：规定了数据模块是如何被处理模块进行加工的流程关系。检查处理模块与数据模块之间的对应关系；处理模块与数据模块之间的存取关系，如建立、删除、查询、修改等。
3.**模块结构与功能结构之间的对应关系**：包括功能结构与控制流结构的对应关系；功能结构与数据流结构的对应关系；每个模块的定义（包括功能、输入与输出数据）。

---

## McCabe复杂度

**软件复杂性**度量是软件度量的一个重要分支。软件复杂性度量的参数有很多，主要包括：1.**规模**，即**指令数或者源程序行数**；2.**难度**，通常由程序中出现的操作数所决定的量来表示；3.**结构**，通常用与程序结构有关的度量来表示；4.**智能度**，即**算法**的难易程度。             

![1698069085345](10软考开发模型.assets\1698069085345.png)

单向链表的复杂度为1 忘了的话就用这个验证

## 系统运行和维护

![1698070386815](10软考开发模型.assets\1698070386815.png)

适应性维护：适应新系统，新的生态，新的市场变化等等

预防性维护：现在不维护没事 但未来可能产生问题 文档现在写不写现在没事 以后维护起来就麻烦

---

### 软件风险  

分类：
影响软件项目的风险主要有三种类别：

- **项目风险**涉及到各种形式的预算、进度、人员、资源以及和客户相关的问题；
- **技术风险**涉及到潜在的设计、实现、对接、测试即维护问题；
- **业务风险**组括建立一个无人想要的优秀产品的风险、失去预算或人员承诺的风险等；         

商业风险包括如市场风险、策略风险、管理风险和预算风险等。    

特性：**不确定性和损失**，其中不确定性是指风险可能发生，也可能不发生：损失是当风险确实发生时，会引起的不希望的后果和损失。所以评估要从风险发生的可能性以及可能导致的后果两方面下手。   

软件风险管理策略：救火和危机管理。

已知风险和未知风险是对软件风险进行分类的一种方式。

**员工和预算**是在识别项目风险时需要识别的**因素**。

**风险管理**是软件项目管理的一项重要任务。在进行风险管理时，根据**风险的优先级**来确定**风险控制策略**，而**优先级**是根据**风险暴露**来确定的。**风险暴露**是一种**量化风险影响**的指标，**等于风险影响乘以风险概率**，风险影响是当风险发生时造成的损失。风险概率是风险发生的可能性。                

- 风险分析：**风险识别、风险预测、风险评估和风险控制**。 风险识别是试图系统化地**确定**对项目计划（估算、进度、资源分配）的**威胁**。
- **风险预测**又称为风险估算，它**从两个方面评估一个风险：风险发生的可能性**；**以及如果风险发生时所产生的后果**。
- **风险评估**根据风险及其发生的概率和产生的影响**预测是否影响参考水平值**。
- **风险控制**的目的是**辅助项目组建立处理风险的策略**，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划。  

风险控制策略：

- **风险避免即放弃或不进行可能带来损失的活动或工作**。例如，为了避免洪水风险，可以把工厂建在地势较高、排水方便的地方，这是一种主动的风险控制方法。
- **风险监控**是指在决策主体的运行过程中，**对风险的发展与变化情况进行全程监督**，并根据需要进行应对策略的**调整**。
- **风险管理**是指在一个肯定有风险的环境里**把风险减至最低**的管理过程。**对于风险我们可以转移，可以规避，但不能消除**。   

**优先级是根据风险暴露来确定的**。风险暴露是一种量化风险影响的指标，**等于风险影响乘以风险概率**，风险影响是当风险发生时造成的损失。风险概率是风险发生的可能性。风险控制是风险管理的一个重要活动。                       

---

## 软件过程改进——CMMI

![1698824995181](10软考开发模型.assets\1698824995181.png)

已管理级：项目级
已定义级：文档化，标准化，组织级，公司已经有相应的模版和工具
定量管理级：量化
优化级：持续优化

CMMI支持阶段性改进和连续性改进。

---

## 项目估算

成本超出某个限度可能导致客户取消项目，而过低的成本估算可能会迫使开发小组投入大量的时间却没有相应的经济回报。

估算方法有**专家判断方法**，该方法受到专家经验和**主观**性等方面的影响；**算法方法**，根据某个计算模型来估算项目开发成本，如**启发式方法COCOMO 模型**，但这些**模型中的参数难以确定**；**机器学习**方法，如根据过去的项目开发数据，建立分类模型，预测新项目的开发成本，但这类方法**难以定义**训练**数据的特征**以及定义数据对象之间的相似性。即使结合多种方法，上述问题仍然存在，因此并不能得到精确地估算结果。

COCOMO用3个不同层次的模型来反映不同程度的复杂性，它们分别为：
基本模型（Basic Model）：是一个静态单变量模型，它用一个以已估算出来的源代码行数（LOC）为自变量的函数来计算软件开发工作量。
中级模型（Intermediate Model）：则在用LOC为自变量的函数计算软件开发工作量的基础上，再用涉及产品、硬件、人员、项目等方面属性的影响因素来调整工作量的估算。
详细模型（Detailed Model）：包括中级COCOMO型的所有特性，但用上述各种影响因素调整工作量估算时，还要考虑对软件工程过程中分析、设计等各步骤的影响。             

Wolverton模型基于一个成本矩阵，定义不同的软件类型（如控制、输入/输出等）和难易（容易和困难）的成本，基于此计算软件开发的成本。COCOMO模型将规模视为成本的主要因素，考虑多个成本驱动因子。在后来的版本COCOMO II中，还考虑了软件开发的不同阶段，包含三个阶段性模型，即应用组装模型、早期设计阶段模型和体系结构阶段模型。             

---

PERT图显示各任务什么时候开始，结束以及依赖关系，但**难以表达并行**关系。
Gantt 图以日历为基准描述项目任务，可以**清楚地表示**任务的持续时间和任务之间的**并行**，但是**不能清晰地描述**各个任务**之间的依赖**关系。         

pert  图：    

![1698825633042](10软考开发模型.assets\1698825633042.png)
